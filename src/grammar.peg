// Kevin Language
// ==============

{
  function tvc(t, v, c) {
    return {t,v,c}
  }
  const functions = [];
}

Function
  = "fn " _ name:FunctionName _ "(" ")" _ block:Block  {
    functions.push(name);
    console.log(functions)
    return tvc("function", { name, block }, "void " + name + "(){\n" + block.c + "}")
  }
  / "fn " _ type:TypeName _ name:FunctionName _ "(" ")" _ block:Block  { return name }

FunctionCall
  = name:FunctionName _ "(" ")"

FunctionName
  = [A-Z][a-zA-Z0-9]* { return text(); }

TypeName
  = name:(BoxName / PrimitiveName) ptype:[*?!]? ("[]")? { return tvc("typename", {}, name + (ptype ? "*" : "")); }

BoxName
  = name:([A-Z][a-zA-Z0-9]*) { return text() }

PrimitiveName
  = name:("bool"/"i"[0-9]+/"f"[0-9]+) { return text() }

VarName
  = [a-z0-9_]+ {return text();}

Block
  = "{" _ statements:(Statement _ ";" _)* "}" {
    return tvc("block", {}, statements.map((s)=>s[0].c).join(";") + ";\n");
  }

Statement
  = a:Assignment { return tvc("statement", {}, a.c) }
  / Block

Expression
  = factors:(Factor _)+ { return tvc("expression", {}, factors.map(f=>f[0].c).join(" ")) }

Factor
  = "hi"
  / "(" _ expr:Expression _ ")"
  / t:Term { return tvc("mathop", {}, t[0] + t[2].c) }
  / val:Literal { return tvc("literal", {}, val) }

Term
  = op:"^" _ right:Expression
  / op:("*"/"/") _ right:Expression
  / op:("+"/"-") _ right:Expression

Literal
  = [0-9]+ { return text(); }
  / "'" ("\\'"/[^'])* "'" { return text() }

Assignment
  = type:("let" _ "mut"? _ TypeName?)? _ name:VarName _ "=" _ expr:Expression {
    return tvc(
      "assignment",
      {},
      (type ? type[4].c + " " : "") + name + "=" + expr.c
    );
}
_ "Whitespace"
  = [ \r\n\t]*
