#include "function"
#include "literals"
#include "names"

Expression
  = head:ExpressionHead

ExpressionPrimary
  = v:FunctionCall { return { type: "function_call", ...v }; }
  / v:Lambda { return { type: "lambda", ...v}; }
  / v:VariableName filtered:"!"? { return { type: "variable", name: v, ...(filtered ? {filtered: true}:{}) }; }
  / v:Literal { return { type: "literal", staticType: v.t, ...v }; }
  / "(" _ v:Expression _ ")" { return v; }
  / Tuple

Tuple
  = "(" _ head:Expression tail:(_ "," _ Expression)+ _ ")"
    {
      const props = [ head, ...tail.map(t => t[3]) ];
      return { type: "tuple", v:props };
    }

ExpressionProperty
  = head:ExpressionPrimary tail:(_ "." _ VariableName)*
    { return buildBinaryExpression(head, tail); }

ExpressionMult
  = head:ExpressionProperty tail:(_ OperatorMult _ ExpressionProperty)*
    { return buildBinaryExpression(head, tail); }

OperatorMult
  = $("*" ![=])
  / $("/" ![=])
  / $("%" ![=])

ExpressionAdd
  = head:ExpressionMult tail:(_ OperatorAdd _ ExpressionMult)*
    { return buildBinaryExpression(head, tail); }

OperatorAdd
  = $("+" ![+=])
  / $("-" ![-=])

ExpressionFunctionChain
  = head:ExpressionAdd tail:(_ "." _ FunctionCall)*
    { return tail.reduce((result, element) => ({
        type: "function_call",
        name: element[3].name,
        ...element[3],
        args: [result, ...element[3].args]
      }), head); }


ExpressionCompare
  = head:ExpressionFunctionChain tail:(_ OperatorCompare _ ExpressionFunctionChain)*
    { return buildBinaryExpression(head, tail); }

OperatorCompare
  = "=="
  / "<="
  / ">="
  / "<"
  / ">"

ExpressionLogical
  = head:ExpressionCompare tail:(_ OperatorLogical _ ExpressionCompare)*
    { return buildBinaryExpression(head, tail); }

OperatorLogical
  = "&&"
  / "||"

ExpressionEject
  = head:ExpressionLogical tail:(_ "eject" _ ExpressionLogical)*
    { return buildBinaryExpression(head, tail); }

ExpressionSequence
  = head:ExpressionLogical? tail:(_ "," _ ExpressionLogical)*
    { return head ? [ head, ...tail.map(t => t[3]) ] : []; }

ExpressionHead
  = ExpressionEject
