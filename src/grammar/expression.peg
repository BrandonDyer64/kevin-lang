#include "function"
#include "literals"
#include "names"

Expression
  = head:ExpressionHead

ExpressionPrimary
  = v:VariableName filtered:"!"? { return { type: "variable", name: v, ...(filtered ? {filtered: true}:{}) }; }
  / v:Literal { return { t: "literal", type: v.t, v:v.v }; }
  / "(" _ v:Expression _ ")" { return v; }
  / FunctionCall
  / Tuple

Tuple
  = "(" _ head:Expression tail:(_ "," _ Expression)+ _ ")"
    {
      const props = [ head, ...tail.map(t => t[3]) ];
      return { type: "tuple", v:props };
    }

ExpressionProperty
  = head:ExpressionPrimary tail:(_ "." _ VariableName)*
    { return buildBinaryExpression(head, tail); }

ExpressionMult
  = head:ExpressionPrimary tail:(_ OperatorMult _ ExpressionPrimary)*
    { return buildBinaryExpression(head, tail); }

OperatorMult
  = $("*" ![=])
  / $("/" ![=])
  / $("%" ![=])

ExpressionAdd
  = head:ExpressionMult tail:(_ OperatorAdd _ ExpressionMult)*
    { return buildBinaryExpression(head, tail); }

OperatorAdd
  = $("+" ![+=])
  / $("-" ![-=])

ExpressionFunctionChain
  = head:ExpressionAdd tail:(_ "." _ FunctionName _ "(" _ ExpressionSequence _ ")")*
    { return tail.reduce((result, element) => ({
        t: "function_chain",
        name: element[3],
        args: [result, ...element[7]]
      }), head); }


ExpressionEject
  = head:ExpressionFunctionChain tail:(_ "fuckit" _ ExpressionFunctionChain)*
    { return buildBinaryExpression(head, tail); }

ExpressionSequence
  = head:ExpressionEject? tail:(_ "," _ ExpressionEject)* {
    return head ? [ head, ...tail.map(t => t[3]) ] : []
  }

ExpressionHead
  = ExpressionEject
