#include "expression"
#include "function"
#include "names"

Statement
  = factor:StatementFactor {
    return factor
  }

StatementFactor
  = v:AssignmentStatement _ ";" {
    return { type: "assignment", ...v };
  }
  / v:FunctionCall _ ";" {
    return { type: "function_call", ...v };
  }
  / v:IfStatement {
    return { type: "if", ...v };
  }
  / v:ReturnStatement _ ";" {
    return { type: "return", ...v };
  }
  / v:Scope {
    return { type: "scope", ...v };
  }

AssignmentStatement
  = dec:("let" / "var")? _ mut:("mut" / "watch")? _ assignment:Assignment {
    return { dec, mut, ...assignment }
  }

Assignment
  = name:VariableName _ "=" _ expr:Expression {
    return { name, expr }
  }
  / staticType:TypeName _ name:VariableName _ "=" _ expr:Expression {
    return { name, expr, staticType }
  }

IfStatement
  = "if" _ expr:Expression _ stmt:Statement _ elsee:("else" _ Statement)? {
    return { expr, stmt, "else": elsee ? elsee[2] : null }
  }

ReturnStatement
  = "return " _ expr:Expression {
    return { expr }
  }
  / Expression

Scope
  = "{" _ statements:(_ Statement _)* _ "}" {
    return statements.map(s => s[1])
  }
  / "=>" _ expr:Expression _ ";"? {
    return [{t: "return", expr}]
  }
